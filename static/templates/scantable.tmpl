<style>

h1 { margin-bottom: 12px; }
.controls { margin-bottom: 12px; display: flex; gap: 12px; flex-wrap: wrap; }
.chip { display: inline-flex; align-items: center; }
table { border-collapse: collapse; width: 100%; }
th, td { padding: 8px 10px; border-bottom: 1px solid #eee; text-align: left; }
th { user-select: none; cursor: pointer; position: sticky; top: 0; background: #fafafa; }
tr:hover td { background: #fcfcff; }
.sortable::after { content: " ↕"; opacity: 0.5; }
th[data-sort-dir="asc"]::after  { content: " ↑"; }
th[data-sort-dir="desc"]::after { content: " ↓"; }
.hidden-col { display: none; }
.muted { color: #777; font-size: 12px; }
</style>

<section>
<article id="article" class="wide">

  <h1>{{.Title}}</h1>

  <!-- Column toggles -->
  <div class="controls" id="column-toggles">
    <span class="muted">Show/Hide columns:</span>
    {{range $i, $col := .Columns}}
      <label class="chip">
        {{if index $.Selected $col}}
        <input type="checkbox" class="col-toggle" data-col="{{$col}}" checked>
        {{else}}
        <input type="checkbox" class="col-toggle" data-col="{{$col}}">
        {{end}}
        {{$col}}
      </label>
    {{end}}
  </div>

  <div class="muted">Tip: click a header to sort. Click again to toggle sort direction.</div>

  <table id="data-table">
    <thead>
      <tr>
        {{range $i, $col := .Columns}}
          {{if index $.Selected $col}}
          <th class="sortable" data-col="{{$col}}" data-sort-dir="">
          {{else}}
          <th class="hidden-col" data-col="{{$col}}" data-sort-dir="">
          {{end}}
          {{$col}}
          </th>
        {{end}}
      </tr>
    </thead>
    <tbody>
      {{/* render each row */}}
      {{range $rIdx, $row := .Rows}}
        <tr>
          {{range $i, $col := $.Columns}}
            {{if index $.Selected $col}}
            <td data-col="{{$col}}">
            {{else}}
            <td class="hidden-col" data-col="{{$col}}">
            {{end}}
              {{index $row $col}}
            </td>
          {{end}}
        </tr>
      {{end}}
    </tbody>
  </table>

</article>
</section>

<script>
(function(){
  const table = document.getElementById('data-table');
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');

  // Sorting
  function parseVal(s) {
    // Try numeric
    const n = Number(s);
    if (!Number.isNaN(n) && s.trim() !== "") return {v:n, t:"num"};
    // Fallback string (case-insensitive)
    return {v: s.toLowerCase(), t:"str"};
  }

  function compare(a, b) {
    if (a.t === "num" && b.t === "num") return a.v - b.v;
    if (a.v < b.v) return -1;
    if (a.v > b.v) return 1;
    return 0;
  }

  function renderCell(col, val) {
    if (col === "start_time") {
      const t = Number(val);
      if (!isNaN(t)) {
        return new Date(t*1000).toISOString(); // unix → ISO8601
      }
    }
    return val;
  }
  //
  // initial render
  tbody.querySelectorAll('td').forEach(td=>{
    td.textContent = renderCell(td.dataset.col, td.textContent);
  });

  thead.addEventListener('click', (e) => {
    const th = e.target.closest('th.sortable');
    if (!th) return;

    const col = th.dataset.col;
    // Determine next direction
    const current = th.dataset.sortDir || "";
    const nextDir = current === "asc" ? "desc" : "asc";

    // Clear indicators on other headers
    thead.querySelectorAll('th.sortable').forEach(h => {
      if (h !== th) h.dataset.sortDir = "";
    });
    th.dataset.sortDir = nextDir;

    // Collect rows
    const rows = Array.from(tbody.querySelectorAll('tr'));
    rows.sort((r1, r2) => {
      const c1 = r1.querySelector(`td[data-col="${CSS.escape(col)}"]`);
      const c2 = r2.querySelector(`td[data-col="${CSS.escape(col)}"]`);
      const v1 = parseVal(c1 ? c1.textContent : "");
      const v2 = parseVal(c2 ? c2.textContent : "");
      const base = compare(v1, v2);
      return nextDir === "asc" ? base : -base;
    });

    // Re-append in new order
    rows.forEach(r => tbody.appendChild(r));
  });

  // Column show/hide
  document.getElementById('column-toggles').addEventListener('change', (e) => {
    const cb = e.target.closest('.col-toggle');
    if (!cb) return;
    const col = cb.dataset.col;
    const hide = !cb.checked;

    // Toggle header
    const th = thead.querySelector(`th[data-col="${CSS.escape(col)}"]`);
    if (th) th.classList.toggle('hidden-col', hide);

    // Toggle cells
    tbody.querySelectorAll(`td[data-col="${CSS.escape(col)}"]`).forEach(td => {
      td.classList.toggle('hidden-col', hide);
    });
  });

  // column reorder
  thead.querySelectorAll('th').forEach(th=>{
    th.draggable=true;
    th.addEventListener('dragstart', e=>e.dataTransfer.setData('col', th.dataset.col));
    th.addEventListener('dragover', e=>e.preventDefault());
    th.addEventListener('drop', e=>{
      e.preventDefault();
      const from=e.dataTransfer.getData('col'), to=th.dataset.col;
      if(from===to) return;
      const fromTh=thead.querySelector(`th[data-col="${from}"]`);
      th.parentNode.insertBefore(fromTh, th);
      tbody.querySelectorAll('tr').forEach(row=>{
        const fromTd=row.querySelector(`td[data-col="${from}"]`),
              toTd=row.querySelector(`td[data-col="${to}"]`);
        row.insertBefore(fromTd, toTd);
      });
    });
  });
})();

</script>
